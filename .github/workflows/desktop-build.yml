name: Build Desktop App

on:
  workflow_dispatch:
    inputs:
      platform:
        description: 'Platform to build'
        required: true
        default: all
        type: choice
        options:
          - all
          - macos
          - windows
          - linux
      macos_sign_and_notarize:
        description: 'Sign and notarize macOS build'
        required: true
        default: true
        type: boolean

concurrency:
  group: desktop-build-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  NODE_VERSION: 22
  PNPM_VERSION: 10.13.1
  RUST_TOOLCHAIN: nightly-2025-12-04
  CARGO_TERM_COLOR: always

jobs:
  tauri-build:
    name: Build ${{ matrix.platform }}
    runs-on: ${{ matrix.platform == 'macos' && 'macos-latest' || matrix.platform == 'windows' && 'windows-latest' || 'ubuntu-22.04' }}
    strategy:
      fail-fast: false
      matrix:
        platform: ${{ fromJSON(inputs.platform == 'all' && '["macos","windows","linux"]' || format('["{0}"]', inputs.platform)) }}

    steps:
      - uses: actions/checkout@v6

      - name: Resolve artifact metadata
        id: artifact_meta
        shell: bash
        run: |
          set -euo pipefail
          case "${{ matrix.platform }}" in
            macos)
              echo "name=desktop-macos" >> "$GITHUB_OUTPUT"
              ;;
            windows)
              echo "name=desktop-windows" >> "$GITHUB_OUTPUT"
              ;;
            linux)
              echo "name=desktop-linux" >> "$GITHUB_OUTPUT"
              ;;
            *)
              echo "::error::Unsupported platform: ${{ matrix.platform }}"
              exit 1
              ;;
          esac

      - name: Setup Node
        uses: ./.github/actions/setup-node

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_TOOLCHAIN }}

      - name: Install Linux system dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          DEBIAN_FRONTEND=noninteractive sudo apt-get install -y \
            libwebkit2gtk-4.0-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libssl-dev \
            patchelf

      - name: Install dependencies
        run: pnpm install

      - name: Build desktop bundle
        run: pnpm desktop:build
        env:
          NODE_OPTIONS: --max-old-space-size=8192

      - name: Detect Windows signing configuration
        id: windows_signing
        if: matrix.platform == 'windows'
        shell: pwsh
        env:
          WINDOWS_CERTIFICATE_PFX_BASE64: ${{ secrets.WINDOWS_CERTIFICATE_PFX_BASE64 }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
          WINDOWS_TIMESTAMP_URL: ${{ secrets.WINDOWS_TIMESTAMP_URL }}
        run: |
          $enabled = $true
          if ([string]::IsNullOrWhiteSpace($env:WINDOWS_CERTIFICATE_PFX_BASE64)) {
            Write-Warning "Missing secret: WINDOWS_CERTIFICATE_PFX_BASE64"
            $enabled = $false
          }
          if ([string]::IsNullOrWhiteSpace($env:WINDOWS_CERTIFICATE_PASSWORD)) {
            Write-Warning "Missing secret: WINDOWS_CERTIFICATE_PASSWORD"
            $enabled = $false
          }

          if (-not $enabled) {
            Write-Host "::notice::Windows signing disabled. Will upload unsigned MSI."
            "enabled=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            exit 0
          }

          $timestampUrl = $env:WINDOWS_TIMESTAMP_URL
          if ([string]::IsNullOrWhiteSpace($timestampUrl)) {
            $timestampUrl = "http://timestamp.digicert.com"
          }

          "enabled=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "timestamp_url=$timestampUrl" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Prepare Windows signing certificate
        if: matrix.platform == 'windows' && steps.windows_signing.outputs.enabled == 'true'
        shell: pwsh
        env:
          WINDOWS_CERTIFICATE_PFX_BASE64: ${{ secrets.WINDOWS_CERTIFICATE_PFX_BASE64 }}
        run: |
          [System.IO.File]::WriteAllBytes(
            "windows-signing-cert.pfx",
            [System.Convert]::FromBase64String($env:WINDOWS_CERTIFICATE_PFX_BASE64)
          )

      - name: Sign Windows MSI artifacts
        if: matrix.platform == 'windows' && steps.windows_signing.outputs.enabled == 'true'
        shell: pwsh
        env:
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
          WINDOWS_TIMESTAMP_URL: ${{ steps.windows_signing.outputs.timestamp_url }}
        run: |
          $msiFiles = Get-ChildItem -Path "src-tauri/target/release/bundle/msi" -Filter *.msi -File
          if ($msiFiles.Count -eq 0) {
            throw "No MSI files found to sign."
          }

          $signtool = (Get-Command signtool.exe -ErrorAction Stop).Source
          foreach ($file in $msiFiles) {
            & $signtool sign /fd SHA256 /td SHA256 /f "windows-signing-cert.pfx" /p "$env:WINDOWS_CERTIFICATE_PASSWORD" /tr "$env:WINDOWS_TIMESTAMP_URL" "$($file.FullName)"
            if ($LASTEXITCODE -ne 0) {
              throw "Failed to sign MSI: $($file.FullName)"
            }

            & $signtool verify /pa "$($file.FullName)"
            if ($LASTEXITCODE -ne 0) {
              throw "Signature verification failed for MSI: $($file.FullName)"
            }
          }

      - name: Validate macOS signing secrets
        if: runner.os == 'macOS' && inputs.macos_sign_and_notarize == 'true'
        shell: bash
        env:
          APPLE_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_CERTIFICATE_P12_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APP_STORE_API_KEY: ${{ secrets.APP_STORE_API_KEY }}
        run: |
          set -euo pipefail
          missing=0
          for key in APPLE_CERTIFICATE_P12_BASE64 APPLE_CERTIFICATE_PASSWORD APP_STORE_API_KEY; do
            if [ -z "${!key}" ]; then
              echo "::error::Missing secret: $key"
              missing=1
            fi
          done
          if [ "$missing" -ne 0 ]; then
            exit 1
          fi

      - name: Resolve macOS bundle path
        id: macos_bundle
        if: runner.os == 'macOS' && inputs.macos_sign_and_notarize == 'true'
        shell: bash
        run: |
          set -euo pipefail
          app_path=$(find src-tauri/target/release/bundle/macos -maxdepth 1 -name '*.app' | head -n 1 || true)
          if [ -z "$app_path" ]; then
            echo "::error::No .app bundle found under src-tauri/target/release/bundle/macos"
            exit 1
          fi
          mkdir -p signed
          echo "app_path=$app_path" >> "$GITHUB_OUTPUT"

      - name: Prepare Apple certificate and API key
        if: runner.os == 'macOS' && inputs.macos_sign_and_notarize == 'true'
        shell: bash
        env:
          APPLE_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_CERTIFICATE_P12_BASE64 }}
          APP_STORE_API_KEY: ${{ secrets.APP_STORE_API_KEY }}
        run: |
          set -euo pipefail
          echo "$APPLE_CERTIFICATE_P12_BASE64" | base64 --decode > certificate.p12
          printf '%s' "$APP_STORE_API_KEY" > app_store_key.json

      - name: Sign macOS app bundle
        if: runner.os == 'macOS' && inputs.macos_sign_and_notarize == 'true'
        uses: BloopAI/apple-code-sign-action@v1
        with:
          input_path: ${{ steps.macos_bundle.outputs.app_path }}
          output_path: signed/agents-chatgroup.app
          p12_file: certificate.p12
          p12_password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          sign: true
          sign_args: '--code-signature-flags=runtime'

      - name: Create signed DMG from signed app
        id: signed_dmg
        if: runner.os == 'macOS' && inputs.macos_sign_and_notarize == 'true'
        shell: bash
        run: |
          set -euo pipefail
          signed_dmg='src-tauri/target/release/bundle/dmg/agents-chatgroup-signed.dmg'
          rm -f "$signed_dmg"
          hdiutil create -volname 'agents-chatgroup' -srcfolder 'signed/agents-chatgroup.app' -ov -format UDZO "$signed_dmg"
          echo "signed_dmg=$signed_dmg" >> "$GITHUB_OUTPUT"

      - name: Notarize signed DMG (macOS)
        if: runner.os == 'macOS' && inputs.macos_sign_and_notarize == 'true'
        uses: BloopAI/apple-code-sign-action@main
        with:
          input_path: ${{ steps.signed_dmg.outputs.signed_dmg }}
          sign: false
          notarize: true
          app_store_connect_api_key_json_file: app_store_key.json

      - name: Staple notarization ticket to DMG
        if: runner.os == 'macOS' && inputs.macos_sign_and_notarize == 'true'
        shell: bash
        run: |
          set -euo pipefail
          xcrun stapler staple '${{ steps.signed_dmg.outputs.signed_dmg }}'

      - name: Upload signed desktop artifacts (macOS)
        if: runner.os == 'macOS' && inputs.macos_sign_and_notarize == 'true'
        uses: actions/upload-artifact@v6
        with:
          name: ${{ steps.artifact_meta.outputs.name }}
          path: |
            src-tauri/target/release/bundle/dmg/agents-chatgroup-signed.dmg
          if-no-files-found: error
          retention-days: 7

      - name: Upload desktop artifacts
        if: matrix.platform == 'windows'
        uses: actions/upload-artifact@v6
        with:
          name: ${{ steps.artifact_meta.outputs.name }}
          path: |
            src-tauri/target/release/bundle/msi/*.msi
          if-no-files-found: error
          retention-days: 7

      - name: Upload desktop artifacts (Linux)
        if: matrix.platform == 'linux'
        uses: actions/upload-artifact@v6
        with:
          name: ${{ steps.artifact_meta.outputs.name }}
          path: |
            src-tauri/target/release/bundle/appimage/*.AppImage
            src-tauri/target/release/bundle/deb/*.deb
          if-no-files-found: error
          retention-days: 7

      - name: Upload desktop artifacts (macOS unsigned)
        if: matrix.platform == 'macos' && inputs.macos_sign_and_notarize != 'true'
        uses: actions/upload-artifact@v6
        with:
          name: ${{ steps.artifact_meta.outputs.name }}
          path: |
            src-tauri/target/release/bundle/dmg/*.dmg
          if-no-files-found: error
          retention-days: 7

      - name: Prepare desktop package bundle
        id: package_bundle
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p gh-package/files

          if [[ "${{ matrix.platform }}" == "macos" && "${{ inputs.macos_sign_and_notarize }}" == "true" ]]; then
            cp src-tauri/target/release/bundle/dmg/agents-chatgroup-signed.dmg gh-package/files/
          elif [[ "${{ matrix.platform }}" == "linux" ]]; then
            cp src-tauri/target/release/bundle/appimage/*.AppImage gh-package/files/
            cp src-tauri/target/release/bundle/deb/*.deb gh-package/files/
          elif [[ "${{ matrix.platform }}" == "windows" ]]; then
            cp src-tauri/target/release/bundle/msi/*.msi gh-package/files/
          else
            cp src-tauri/target/release/bundle/dmg/*.dmg gh-package/files/
          fi

          if ! compgen -G "gh-package/files/*" > /dev/null; then
            echo "::error::No desktop files found to package for ${{ matrix.platform }}"
            exit 1
          fi

          bundle_name="agents-chatgroup-desktop-${{ matrix.platform }}-${{ github.sha }}.tar.gz"
          (cd gh-package/files && tar -czf "../${bundle_name}" .)
          (cd gh-package && sha256sum "${bundle_name}" > "${bundle_name}.sha256")

          echo "bundle_name=${bundle_name}" >> "$GITHUB_OUTPUT"

      - name: Upload desktop package bundle (direct download)
        uses: actions/upload-artifact@v6
        with:
          name: desktop-package-${{ matrix.platform }}
          path: |
            gh-package/${{ steps.package_bundle.outputs.bundle_name }}
            gh-package/${{ steps.package_bundle.outputs.bundle_name }}.sha256
          if-no-files-found: error
          retention-days: 7

      - name: Clean up signing files (macOS)
        if: runner.os == 'macOS' && always()
        shell: bash
        run: |
          rm -f certificate.p12 app_store_key.json

      - name: Clean up signing files (Windows)
        if: matrix.platform == 'windows' && always()
        shell: pwsh
        run: |
          Remove-Item -Path "windows-signing-cert.pfx" -Force -ErrorAction SilentlyContinue
